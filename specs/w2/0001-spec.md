# DB Query Tool 需求与设计文档

## 1. 概述

### 1.1 项目目标
提供一个数据库查询工具，用户可以：
- 添加数据库连接 URL
- 系统自动连接数据库并获取 metadata（表和视图信息）
- 展示数据库中的表和视图信息
- 直接输入 SQL 查询
- 使用自然语言生成 SQL 查询

### 1.2 核心能力
- 数据库连接管理（添加、删除、测试连接）
- 自动获取并存储数据库 metadata
- SQL 查询执行与结果展示
- 自然语言转 SQL（基于 LLM）
- SQL 语法验证与安全控制

### 1.3 非目标
- 用户认证与权限管理
- 数据修改操作（INSERT/UPDATE/DELETE）
- 数据库管理功能（创建表、修改结构等）
- 多租户支持

## 2. 核心功能需求

### 2.1 数据库连接管理

#### 2.1.1 添加数据库连接
- **输入**：数据库连接字符串（URL）、连接名称、数据库类型
- **处理流程**：
  1. 验证连接字符串格式
  2. 测试数据库连接
  3. 存储连接信息到 SQLite 数据库
  4. 自动触发 metadata 获取流程
- **存储结构**：
  - `id`: 唯一标识
  - `name`: 连接名称
  - `connection_string`: 数据库连接字符串
  - `database_type`: 数据库类型（postgresql, mysql 等）
  - `created_at`: 创建时间
  - `updated_at`: 更新时间

#### 2.1.2 删除数据库连接
- 删除连接记录
- 同时删除关联的 metadata 记录

#### 2.1.3 测试连接
- 验证连接字符串是否有效
- 返回连接状态和错误信息

### 2.2 Metadata 获取与存储

#### 2.2.1 Metadata 获取流程
1. **从数据库查询原始 metadata**
   - 对于 PostgreSQL：查询 `information_schema.tables` 和 `information_schema.columns`
   - 获取所有表和视图的信息，包括：
     - 表/视图名称
     - 列名、数据类型、是否可空、默认值
     - 表类型（BASE TABLE 或 VIEW）

2. **LLM 转换处理**
   - 将原始 metadata 传递给 LLM
   - LLM 将信息转换为结构化的 JSON 格式
   - JSON 格式示例：
     ```json
     {
       "tables": [
         {
           "name": "schema.table_name",
           "type": "table",
           "columns": [
             {
               "name": "column_name",
               "type": "varchar",
               "nullable": true,
               "default": null
             }
           ]
         }
       ]
     }
     ```

3. **存储到 SQLite**
   - 将转换后的 JSON 存储到 `database_metadata` 表
   - 存储结构：
     - `id`: 唯一标识
     - `connection_id`: 关联的数据库连接 ID
     - `metadata_json`: JSON 格式的 metadata（TEXT 类型）
     - `created_at`: 创建时间
     - `updated_at`: 更新时间

#### 2.2.2 Metadata 复用机制
- Metadata 存储在 SQLite 中，避免重复查询源数据库
- 支持手动刷新 metadata（当数据库结构变化时）
- 查询时优先使用缓存的 metadata

### 2.3 SQL 查询功能

#### 2.3.1 SQL 输入与验证
- **输入验证流程**：
  1. 使用 `sqlglot` 解析 SQL 语句
  2. 验证语法正确性
  3. **仅允许 SELECT 语句**（拒绝 INSERT/UPDATE/DELETE/DROP 等）
  4. 如果语法错误或包含非 SELECT 语句，返回详细错误信息

#### 2.3.2 LIMIT 自动添加
- 检查 SQL 语句是否包含 LIMIT 子句
- 如果**不包含 LIMIT**，自动在查询末尾添加 `LIMIT 1000`
- 如果已包含 LIMIT，保持原样
- 示例：
  - 输入：`SELECT * FROM users`
  - 处理后：`SELECT * FROM users LIMIT 1000`
  - 输入：`SELECT * FROM users LIMIT 100`
  - 处理后：`SELECT * FROM users LIMIT 100`（不变）

#### 2.3.3 查询执行
- 连接到目标数据库
- 执行验证后的 SQL 语句
- 获取查询结果
- 返回 JSON 格式的结果

#### 2.3.4 结果格式
- **JSON 响应格式**（camelCase）：
  ```json
  {
    "columns": ["id", "name", "email"],
    "rows": [
      [1, "Alice", "alice@example.com"],
      [2, "Bob", "bob@example.com"]
    ],
    "rowCount": 2
  }
  ```

### 2.4 自然语言生成 SQL

#### 2.4.1 自然语言输入
- 用户输入自然语言查询需求
- 示例：
  - "查询所有用户的信息"
  - "显示订单表中金额大于 1000 的记录"
  - "找出最近 7 天创建的订单"

#### 2.4.2 LLM 生成 SQL 流程
1. **准备 Context**：
   - 从 SQLite 中获取对应连接的 metadata
   - 将 metadata JSON 转换为易读的文本格式
   - 构建 prompt，包含：
     - 数据库 schema 信息（表和列）
     - 用户查询需求
     - 生成规则（仅 SELECT，自动添加 LIMIT）

2. **调用 LLM**：
   - 使用 OpenAI SDK 调用 LLM（GPT-4o-mini 或类似模型）
   - 传递完整的 context
   - 要求 LLM 生成 SQL 查询

3. **SQL 验证**：
   - 对 LLM 生成的 SQL 进行同样的验证流程
   - 确保语法正确且仅包含 SELECT 语句
   - 自动添加 LIMIT 1000（如需要）

4. **返回结果**：
   - 返回生成的 SQL 语句
   - 可选：返回 LLM 的解释说明

#### 2.4.3 响应格式
```json
{
  "sql": "SELECT * FROM users WHERE created_at > NOW() - INTERVAL '7 days' LIMIT 1000",
  "explanation": "查询最近 7 天创建的用户记录"
}
```

## 3. 数据模型设计

### 3.1 SQLite 存储模型

#### 3.1.1 DatabaseConnection 表
```sql
CREATE TABLE database_connections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(200) NOT NULL,
    connection_string TEXT NOT NULL,
    database_type VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.1.2 DatabaseMetadata 表
```sql
CREATE TABLE database_metadata (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    connection_id INTEGER NOT NULL,
    metadata_json TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (connection_id) REFERENCES database_connections(id) ON DELETE CASCADE
);
```

### 3.2 API 数据模型（Pydantic）

#### 3.2.1 数据库连接相关
- `DatabaseConnectionCreate`: 创建连接的请求模型
- `DatabaseConnectionResponse`: 连接信息响应模型

#### 3.2.2 Metadata 相关
- `DatabaseMetadataResponse`: Metadata 响应模型（包含解析后的 JSON）

#### 3.2.3 查询相关
- `SqlQueryRequest`: SQL 查询请求模型
- `SqlQueryResponse`: SQL 查询响应模型
- `NaturalLanguageQueryRequest`: 自然语言查询请求模型
- `NaturalLanguageQueryResponse`: 自然语言查询响应模型

## 4. API 设计

### 4.1 数据库连接管理 API

#### POST /api/connections
创建新的数据库连接
- **请求体**：
  ```json
  {
    "name": "Production DB",
    "connectionString": "postgresql://user:pass@host:5432/dbname",
    "databaseType": "postgresql"
  }
  ```
- **响应**：`DatabaseConnectionResponse`
- **行为**：自动触发 metadata 获取

#### GET /api/connections
获取所有数据库连接列表
- **响应**：`DatabaseConnectionResponse[]`

#### GET /api/connections/{id}
获取单个数据库连接详情
- **响应**：`DatabaseConnectionResponse`

#### DELETE /api/connections/{id}
删除数据库连接
- **响应**：`{ "success": true }`
- **行为**：同时删除关联的 metadata

#### POST /api/connections/{id}/test
测试数据库连接
- **响应**：`{ "success": true, "message": "Connection successful" }`

### 4.2 Metadata API

#### GET /api/metadata/{connection_id}
获取指定连接的 metadata
- **响应**：`DatabaseMetadataResponse`
- **行为**：返回缓存的 metadata，如果不存在则返回 404

#### POST /api/metadata/{connection_id}/refresh
刷新指定连接的 metadata
- **响应**：`DatabaseMetadataResponse`
- **行为**：
  1. 从源数据库重新获取 metadata
  2. 使用 LLM 转换格式
  3. 更新或创建 metadata 记录

### 4.3 查询 API

#### POST /api/queries/sql
执行 SQL 查询
- **请求体**：
  ```json
  {
    "connectionId": 1,
    "sql": "SELECT * FROM users"
  }
  ```
- **响应**：`SqlQueryResponse`
- **处理流程**：
  1. 验证 SQL（sqlglot）
  2. 确保仅 SELECT 语句
  3. 自动添加 LIMIT 1000（如需要）
  4. 执行查询
  5. 返回结果

#### POST /api/queries/natural-language
自然语言生成 SQL 并执行
- **请求体**：
  ```json
  {
    "connectionId": 1,
    "query": "查询所有用户的信息"
  }
  ```
- **响应**：`NaturalLanguageQueryResponse` + `SqlQueryResponse`
- **处理流程**：
  1. 获取 connection 的 metadata
  2. 构建 LLM prompt
  3. 调用 LLM 生成 SQL
  4. 验证生成的 SQL
  5. 执行查询
  6. 返回 SQL 和结果

## 5. 安全与限制

### 5.1 SQL 安全控制
- **仅允许 SELECT 语句**：严格禁止所有数据修改操作
- **语法验证**：使用 sqlglot 确保 SQL 语法正确
- **LIMIT 限制**：自动添加 LIMIT 1000，防止返回过多数据

### 5.2 连接安全
- 连接字符串存储在本地 SQLite，不对外暴露
- 支持连接测试，避免无效连接

### 5.3 错误处理
- SQL 语法错误：返回详细的错误信息和位置
- 连接错误：返回连接失败原因
- LLM 错误：返回生成失败信息

## 6. 技术实现要点

### 6.1 后端实现
- **FastAPI**：异步 Web 框架
- **SQLAlchemy (async)**：异步 ORM
- **sqlglot**：SQL 解析和验证
- **OpenAI SDK**：LLM 调用
- **asyncpg**：PostgreSQL 异步驱动
- **aiosqlite**：SQLite 异步驱动

### 6.2 前端实现
- **React + TypeScript**：严格类型标注
- **Refine 5**：数据管理和 UI 框架
- **Ant Design**：UI 组件库
- **Monaco Editor**：SQL 编辑器（代码高亮、自动补全）
- **Tailwind CSS**：样式框架

### 6.3 数据格式
- **后端 JSON 响应**：统一使用 camelCase
- **前端 TypeScript**：严格类型定义
- **Metadata JSON**：结构化的表和列信息

## 7. 用户界面设计

### 7.1 主界面布局
- 左侧：数据库连接列表
- 中间：SQL 编辑器（Monaco Editor）
- 右侧：查询结果表格
- 顶部：自然语言查询输入框

### 7.2 功能区域
1. **连接管理区域**
   - 添加连接按钮
   - 连接列表（显示名称、类型、状态）
   - 删除/刷新操作

2. **Metadata 展示区域**
   - 表和视图列表
   - 点击查看表结构（列信息）

3. **SQL 编辑器区域**
   - Monaco Editor（语法高亮、自动补全）
   - 执行按钮
   - 清除按钮

4. **自然语言查询区域**
   - 输入框
   - 生成 SQL 按钮
   - 显示生成的 SQL

5. **结果展示区域**
   - 表格展示查询结果
   - 分页（如需要）
   - 导出功能（可选）

## 8. 开发里程碑

### M1: 后端基础架构
- 项目结构搭建
- SQLite 数据库模型
- FastAPI 应用框架
- 基础配置管理

### M2: 数据库连接管理
- 连接 CRUD API
- 连接测试功能
- PostgreSQL 连接支持

### M3: Metadata 获取与存储
- PostgreSQL metadata 查询
- LLM 转换功能
- Metadata 存储与检索

### M4: SQL 查询功能
- SQL 解析与验证（sqlglot）
- SELECT 语句限制
- LIMIT 自动添加
- 查询执行与结果返回

### M5: 自然语言生成 SQL
- LLM 集成（OpenAI SDK）
- Context 构建（metadata）
- SQL 生成与验证
- 错误处理

### M6: 前端基础
- React + Refine 5 项目搭建
- 基础 UI 组件
- API 客户端封装

### M7: 前端功能实现
- 连接管理 UI
- Metadata 展示
- SQL 编辑器集成（Monaco）
- 查询结果表格
- 自然语言查询 UI

### M8: 测试与优化
- 单元测试
- 集成测试
- 性能优化
- 错误处理完善

